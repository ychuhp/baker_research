<!DOCTYPE html>
<!--Converted via md-to-html-->
<html>
 <head>
 </head>
 <body>
  <h1>
   Workflow
  </h1>
  <p>
   PARSER -&gt; CA BACKBONE &amp; CA SEQUENCE
  </p>
  <p>
   CA BACKBONE -&gt; CA DISTANCE MATRIX
  </p>
  <p>
   CA SEQUENCE -&gt; HHBlits -&gt; MSA -&gt; MSA PAIR STATISTICS -&gt; 1D FEATURES &amp; DCA FEATURES
  </p>
  <h1>
   PARSER
  </h1>
  <ul>
   <li>
    Select from proteins and chains specified in pdb70_a3m.ffindex
   </li>
  </ul>
  <ul>
   <li>
    Only parse residues which have a CA ATOM
   </li>
  </ul>
  <pre><code>* This style of selective parsing is a workflow parallel to Baker group
</code></pre>
  <ul>
   <li>
    Save the extracted CA BACKBONE and CA SEQUENCE
   </li>
  </ul>
  <h1>
   CA DISTANCE MATRIX
  </h1>
  <p>
   We take the CA BACKBONE
  </p>
  <p>
   For each chain using the CA coordinates we construct a distance matrix, M
  </p>
  <p>
   M[ij] = distance between ith CA's xyz and jth CA's abc coordinates. distance(xyz,abc) = sqrt( (x-a)^2+(y-b)^2+(z-c)^2 )
  </p>
  <ul>
   <li>
    Matrix-based batch calculation
   </li>
  </ul>
  <pre><code>* M = np.stack(L*[chain], axis=1)
</code></pre>
  <pre><code>* sq_dist = ( M-M.transpose([1,0,2]) )**2
</code></pre>
  <pre><code>* np.sqrt( sq_dist.sum(2) )
</code></pre>
  <p>
   It took 2 days to parse and create CA matrices for 85756 chains
  </p>
  <h1>
   MSA
  </h1>
  <p>
   Multiple Sequence Alignment
  </p>
  <p>
   Definition: Given a CA SEQUENCE of length L, find other related sequences to the sequence, which are aligned to the original with gaps, replacement, and deletion. The collection of sequences with length L as a result from this process is called a MSA.
  </p>
  <h2>
   HHblits (Soedinglab)
  </h2>
  <p>
   Classical alignment methods directly compared sequences to determine alignment
  </p>
  <p>
   HMM (Hidden markov machine) alignment methods compare HMM to other HMM by using them as profiles.
  </p>
  <p>
   The alignment tool used in Baker group is HHBlits
  </p>
  <p>
   "HHblits (version 3.0.3) (28) with default parameters at 4 different e-value cutoffs: 1e−40, 1e−10, 1e−3, and 1." (Baker)
  </p>
  <p>
   We ran hhblits with e=.001 n=1
  </p>
  <p>
   -n     [1,8]   number of iterations (default=2)
  </p>
  <p>
   -e     [0,1]   E-value cutoff for inclusion in result alignment (def=0.001)
  </p>
  <p>
   -d database '/raid0/uniclust/uniclust30_2018_08/uniclust30_2018_08'
  </p>
  <p>
   The Expect value is a parameter that describes the number of hits one can "expect" to see by chance when searching a database of a particular size. It decreases exponentially as the Score (S) of the match increases. Essentially, the E value describes the random background noise.
  </p>
  <p>
   It took 4 days to process and create alignments for 85756 chains in uniclust30_2018_08 with 64 separate processes
  </p>
  <h1>
   MSA PAIR STATISTICS
  </h1>
  <p>
   The approach is from Baker group
  </p>
  <p>
   Several information are computed from the sequence and MSA for insertion into the neural network pipeline
  </p>
  <p>
   First, the MSA is converted into a one-hot encoded matrix of shape NxLx21 - (Number sequences in MSA)x(sequence Length)x(aminoacids+gap)
  </p>
  <p>
   From this result, the 1D FEATURES and DCA FEATURES are computed.
  </p>
  <p>
   Finally, they are combined into one feature matrix.
  </p>
  <h2>
   1D FEATURES
  </h2>
  <p>
   1D FEATURES include, sequence information, PSSM, and entropy
  </p>
  <ol>
   <li>
    The sequence information has shape Lx20
   </li>
  </ol>
  <ol>
   <li>
    The PSSM has shape Lx21
   </li>
  </ol>
  <ol>
   <li>
    The entropy has shape Lx1
   </li>
  </ol>
  <p>
   These 3 vectors are combined into a single vector of shape Lx42
  </p>
  <p>
   Then they are tiled L times horizontally and vertically to produce matrices of shape LxLx42 and LxLx42
  </p>
  <p>
   Then they are combined into a single matrix of shape LxLx84
  </p>
  <h3>
   1. sequence information
  </h3>
  <p>
   The sequence of the matrix is one-hot encoded into a matrix of shape Lx20. L is the length of the sequence and 20 is the amino acids.
  </p>
  <p>
   For example if there was a 3 letter amino alphabet with the sequence ABBC, it would be encoded into a shape of 4x3 as
  </p>
  <p>
   A - 100
  </p>
  <p>
   B - 010
  </p>
  <p>
   B - 010
  </p>
  <p>
   C - 001
  </p>
  <h3>
   2. PSSM
  </h3>
  <p>
   Position specific scoring matrix gives a probability of a specific position in L being a certain amino acid or a gap.
  </p>
  <p>
   It has the shape Lx21 where L is the length of the aligned sequences and 21 is the amino acids + gap.
  </p>
  <h3>
   3. Entropy
  </h3>
  <p>
   Entropy is computed using the Shannon entropy formula where entropy = - sum( P_a log(P_a) ) where the sum iterates over P_a, the probabilty of a specific position being an amino acid a.
  </p>
  <p>
   Entropy is calculated for each position in L, resulting in a matrix of shape Lx1.
  </p>
  <h2>
   DCA FEATURES
  </h2>
  <p>
   DCA (direct coupling analysis) features use MSA to create inverse covariance matrix and APC
  </p>
  <ul>
   <li>
    Inverse covariance matrix has shape (L
    <em>
     21)x(L
    </em>
    21)
   </li>
  </ul>
  <pre><code>* They are indexed over the ordered pair i,A. where i is the position in the sequence and A is one of 21 (amino acid+gap)
</code></pre>
  <pre><code>* The expected value is computed for each i,A by counting the weighted sum of the frequencies of i,A occuring in the MSA
</code></pre>
  <pre><code>    * See f_i(A) and f_i,j(A,B) in [Baker pg7].
</code></pre>
  <pre><code>    * These two expected are used to compute the covariance matrix at each position. COV[(i,A),(j,B)] = f_i,j(A,B) - f_i(A)*f_j(B) [eq1 Baker pg7]
</code></pre>
  <pre><code>* After the covariance matrix is computed, it is normalized and inversed
</code></pre>
  <ul>
   <li>
    APC (average product correlation score) has shape LxLx1
   </li>
  </ul>
  <pre><code>* It is a summary statistic from the inverse covariance matrix [eq 3,4 Baker pg7]
</code></pre>
  <p>
   These two features are combined by first reshaping the inverse covariance matrix into a matrix of shape LxLx(21
   <em>
    21) and then concatenating it with the APC into a final matrix of shape LxLx(21
   </em>
   21+1) =  LxL(442)
  </p>
 </body>
</html>